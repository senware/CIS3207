# File System on a Virtual Disk

## Overview
This goal of this project was to create an API with which a virtual disk file could be created, opened and interacted with via a file system.

## virtual_disk.h
#### struct disk save
A struct featuring some data we might want to write to disk.
### Class: virtual_disk
Instanced objects of this class represent the virtual disk.
#### Constructor
If only a name is passed, the constructor will attempt first to load a disk file via `load_disk()` from the the `./disks` directory. If one is found, it's opened at `this->file_descriptor` and it's information is loaded into the first block of the disk. If it is not found, the name of the disk and a default size of 64 MB is passed to `create_disk()`. If the name and a size in MB is passed to the constructor, it will immediately call `create_disk()` with those same parameters. No matter what the case is, `this->block_size` is always `BLOCK_SIZE` defined to be 4096.
#### write_block
The `write_block()` function takes as arguments a char buffer, the size of the buffer, the block to write to and a flag set to either `WRITE` or `OVERWRITE`. It defines an offset as the block * `BLOCK_SIZE` and uses `lseek()` to navigate to that offset in the virtual disk file. It will then call `write()`. If `WRITE` is passed as the flag, it will decrement the free block counter, and call the `save_disk()` function. The `save_disk()` function calls `write_block()`, always in `OVERWRITE` mode at block 0, to save disk metadata to the disk file. Lastly, `write_block()` calls `syncfs()` to ensure data is written to disk as close to real time as possible.
#### read_block
The `read_block()` function calculates the offset and `lseek()`s to it the same way `write_block()` does. It calls read and returns.
#### rm_block
The `rm_block` function increments the free block counter.
#### load_disk
The `load_disk()` function attempts to open the disk file specified by name. This function is meant to be called from the constructor only. If the disk file is found, it creates a `struct disk_save` and loads data from the first block into it. It then copies that data into the disk object.
#### save_disk
The `save_disk()` function saves disk metadata. It does so by creating a `struct disk_save`, filling it with data from the disk object, and then writing it to block 0 of the disk.

## file_system.h
#### enum file_t
Determines whether a `struct vfile` is a file or directory.
#### struct vnode
This struct contains file metadata, always implemented as the first block of a file. The metadata includes a file name up to length 63 + null terminating byte; a file type; the start block, where the metadata itself will be stored; the file size, in blocks, 0 if a directory, and the metadata block is not counted here; the end of file byte, which is the last block in file binary, storing a -1, essentially the actual file size; and up to 256 integers, listing the starting blocks of all directory contents, if this node refers to a directory.
#### struct vfile
This struct is for storing files currently open by the program, whether accessable to the user or not. It has pointers to the file metadata and the file binary, as well as an integer for the file offset.
#### struct entry
This is the tuple stored by the FAT. It has a bool for whether it is occupied or not, and an int to point to the next block of the file.
### Class: file_system
#### Constructor
The constructor takes a disk object as an argument, and the file_system object maintains a reference to it. It allocates memory for the FAT (calculating the size needed by the FAT based on how many total blocks the disk contains, and allocating enough space for an entry for each one) and the root directory. The location of the root directory is set as the block calculated to be the first available block after the FAT is written to disk, based on the size of the disk. This starting block is saved to the object. The `FAT_read()` function is then called, reading from the disk where the FAT ought to be, assuming it already exists on disk. It then checks this capy of the FAT to see if the root block is occupied. If it is not, a `struct vnode` is created and new data for the root directory is filled in. The FAT is then initialized by calling `FAT_init()` with the `WRITE` flag. The root is then copied to disk using the `vfs_sync_file()` function. If the root block is occupied, its metadata block is read into memory, and the file_system object will maintain its reference as `this->root`.
#### vfs_sync_file
This function is the backbone of the file_system class, and is private to the class. I'm only including it here in its own section because it is extremely important, and I'm really rather proud of it. It made writing other functions that use it **much much much** easier. It writes file metadata and binary to disk, while also modifying the FAT as it goes. The function is called in any other function that writes any file data to the disk at all, ensuring that the disk is kept up to date with any changes made by programs using the file system. It takes into account 3 distinct cases: a) a new file is being written to disk, b) the file being written to disk is either larger or the same size as its on-disk counterpart, and c) the file is smaller than its on-disk counterpart. It will issue combinations of `WRITE` and `OVERWRITE` flags to each `write_block()` call it makes every situation. It also calls the virtual_disk function `rm_blocks()` when necessary, as in case (c). I seriously feel bad for anyone working on this project who didn't write a universal sync function like this.
#### vfs_create
The `vfs_create()` function creates a new file in the root directory with a name equal to the string it is passed. If 2 strings are passed, the file is placed in the directory with the name corresponding to the second string. Unfortunately, with the way searching is implemented, and with no parsing functionality, traditional structures like "./directory/directory/file" do not work. Files and directories must also be uniquely named, no matter what directory they are created in. File metadata is filled with the appropriate values. File binaries are created as one block buffers bytes all equal to 0, with the first byte then being set to -1 to mark the end of the file. The end of file variable is therefore set to 0, indicating the file is empty. This function also makes a call to utility function `add_content()`, which adds the new file's starting block to the parent directory's `content[]` field. A call to `vfs_sync_file()` ensures that the file is written to disk, then all allocated memory is freed and the function returns.
#### vfs_mkdir
The `vfs_mkdir()` function behaves almost identically to `vfs_create()`, except a directory is created instead of a file. No binary buffer is created. All directories created have their end of file byte field initialized to -1, as it is expected that this field will not be used. Again, a call to `vfs_sync_file()` ensures data is written to the disk, and all allocated memory is freed.
#### vfs_rm
The `vfs_rm()` function removes a file from the file system. All FAT entries related to the file are removed (entries are set to {0, -1}). This function also makes a call to `rm_content()`, which ensures that its starting block is removed from its parent directory's `content[]` field. It also makes a call to the virtual_disk object's `rm_blocks()` to update the free block counter. All memory allocated by the function is freed upon completion and the function returns. Note: file still technically exists on disk, just like I'm assuming is true with a file system on a real disk. All references to it are, however, removed.
#### vfs_open
The `vfs_open()` function opens a file, returning a file descriptor to be used later for read, write and seek operations on the file. The `vfs_search()` function recursively searches through all directories to find the starting block of the file associated with the string passed to `vfs_open()`, which then creates a file structure and fills it with data from the disk. The file offset is set to the end of file byte, the number of open file descriptors is then incremented, and the index of the first open spot in the file system object's open file table is returned as the file descriptor.
#### vfs_close
The `vfs_close()` function first calls `vfs_sync_file()` to ensure doubly that all changes made to the file are written to disk. The file referenced by the file descriptor passed to `vfs_close()` then has all memory allocated to it freed. The number of open file descriptors is decremented, and the location in the open file table previously held by the file is set to `NULL`.
#### vfs_write
The `vfs_write()` function writes the char buffer passed to it to the file's binary buffer, starting from the file offset. The file must be opened at the file descriptor passed to `vfs_write()`. If the file requires more blocks to do so, then the file is allocated enough blocks to write the entire buffer. Freshly allocated blocks are filled with bytes equal to 0 prior to writing. If the disk does not have enough remaining blocks, the write size is truncated. The end of file byte is set to the end of the new data in this case, as well. After a write, the file offset is set to the end of the write, allowing easy looping of `vfs_write()` calls. Of course, `vfs_sync_file()` is called at the end to write all changes to disk. Failure at this point would likely cause file corruption, and a more enlightened programmer might make a copy of the file first as backup. Note, I am not this enlightened programmer, so a lot of faith is put into `vfs_sync_file()` not screwing up, which should only happen if `vfs_write()` has a fatal error in its programming anyway. Anyway, the total number of bytes written is returned.
#### vfs_read
The `vfs_read()` function reads from the file, starting at the file offset, into the char buffer passed to it. The file must be opened at the file descriptor passed to `vfs_read()`. If it would encounter the end of file marker before reaching the end of the read, the read size is truncated to prevent this. The total number of bytes read is returned.
#### vfs_trunc
The `vfs_trunc()` function moves the file's end of file byte to the location passed to it. The file must be open at the file descriptor passed to `vfs_trunc()`. Note: Once again, no data is really deleted here, but becomes unreachable by the file system. Blocks are unallocated from the FAT if necessary by the call to `vfs_sync_file()`. The file offset is set to the new end of file byte. The file must be open at the file descriptor passed to this function.
#### vfs_seek
The `vfs_seek()` function moves the file offset to the location passed to it. It will return an error if asked to seek past the bounds of the file, be it less than 0 or greater than the end of file location. Obviously, the file must be open, once again, at the file descriptor passed to this function.
#### vfs_get_length
The `vfs_get_length()` function returns the location of the end of file byte of a file open at the file descriptor passed to it. The file must be open at the file descriptor passed to this function.
#### various utility functions
Honorable mentions go out to `vfs_search()` and it's closely related buddy `rec_search()`. `vfs_search()` starts at the root, and `rec_search()` recursively searches all directories for the sought after file or directory's starting block.
The FAT functions (hey, ever hear of a DIET) `FAT_read()`, `FAT_write()` and `FAT_init()` were super helpful as well, especially `FAT_write()`. The `FAT_write()` function is called every time a change to the FAT is made, namely by `vfs_sync_file()`, but by others as well. It does exactly what it sounds like, also taking `WRITE` and `OVERWRITE` flags as necessary and passing them along to its corresponding `write_block()` calls.
The `next_free_block()` function also takes a lot of calls, any time a new block of disk space has to be allocated. Popular guy. It simply iterates through the FAT, looking for the first time it enounters an entry marked with a 0 and returning the index.
The `add_content()` and `remove_content()` functions were touched on briefly above. They simply add and remove directory entries, and are generally called when files are created and removed from directories. They're nice in that they don't allocate any memory themselves. They simply fill a buffer passed to them by the calling function.
